#### 后缀数组

* 定义：给定一个长度为$n$的字符串$S$，要求对于其所有**后缀**排序，即将$S[1..n],S[2..n],...,S[i..n],...,S[n..n]$排序
  * 注意：这里的排序使用字典序，并忽略 字符串长度 对字符串字典序比较产生的影响。即 我们可以想成我们的每一个字符串长度都为$+\infin$，对于长度不足$+\infin $的在字符串后添加无效字符$c$（要求该字符$c$ 小于 有效字符串中所有字符）
* 思路：
  * 首先不难想到我们将每个后缀生成出来，再自己写一个 $cmp()$排序比较函数 ，然后把这些参数全丢给 $sort()$ 函数 来完成排序。但这样的空间复杂度$O(n^2)$，且对于一次$swap()$ 需要的时间是$O(n)$，对于一次$cmp()$ 需要的时间也是$O(n)$，总时间复杂度$O(n^2\log n)​$
  * 这个是空间复杂度是我们所不能承受的，因此要优化。首先我们不难想到一个简单的优化，即：不把每个后缀都生成出来，而是用后缀的起始位置代替整个后缀。这样我们的空间复杂度就可以降为$O(n)$。但时间复杂度限于$cmp()$的时间复杂度，仍然在$O(n^2\log n)$
  * 那么这启发我们**不使用**$cmp()$来进行排序，但这该怎么排序呢？
  * 在排序算法中，唯有 **基数排序** 时间优于$O(n\log n)$，其时间复杂度为$O(kn)$，$k$为比较的位数，在字符串比较中 $k$ 就是$O(n)$。看上去时间复杂度降为 线性再加上一个较大的常数$k$，但根据上述$k$的大小，直接使用 基数排序 的时间复杂度还要劣于$O(n\log n)$，为$O(n^2)$
  * 但是这并不是不能优化的，我们套用 **倍增** 的思想，相当于基数排序就在比较$[i..i+2^k]$和$[i+2^k+1..i+2^{2k}]$两个关键值，这样$k=2$，时间复杂度就降下来了，总时间复杂度 加上一个倍增的复杂度 总共是$O(2*n\log n)$
  * <font color="blue">~~没看懂？一脸懵逼？~~</font>没事，继续往下看
* 实现
  * 我们可以注意到对于一个给定的字符串，他的所有后缀（在不改其原来的位置的情况下）长度是**递增**的。像这种递增的东西，能想到什么？**二分！**对，但和二分仍有些不同，二分是在最优化，而这里要求对于每个后缀都要求，但我们可以用 **倍增**，我们可以这么想，我们先把所有后缀的 长度$\leq 2^k$的前缀 的顺序算出，再利用已有的顺序扩展到长度$\leq 2^{k+1}$的后缀的顺序。
  * 那该怎么做呢？首先我们先假设你手头上已经有所有长度$\leq 2^k$的后缀的大小，现在我们要进行扩展。
  * ![基数排序_1](/Users/duanlingbo/Desktop/OI/knowledge/字符串/后缀数组/基数排序_1.png)
  * 我们不妨先来看个例子，为方便叙述我们称上方的后缀为$a$，下方的后缀为$b$。不难发现，在我们排完前$2^k$长度的前缀后，$b$的前$2^k$的前缀恰好是$a$要扩展的$2^{2k}$的前缀的后$2^k$的字符串的大小。也就是说在排完所有后缀的$2^k$的前缀的顺序后，我们就已经知道$1..2^k$以及$2^k+1..2^{2k}$的大小，这是再套用基数排序，我们就可以扩展到$2^{2k}$的大小。
  * 基数排序排双关键字$(x,y)$就是先排出$y$的顺序，再排$x$的顺序。具体来说就是，$x$的重要性比$y$高，例如：$18$和$23$排序，$18$中的$1$比$8$重要，$23$同理。为什么呢？如果我们先排$18$中的$1$和$23$中的$2$，我们可以排出$18,23$；然后我们再排$18$中的$8$和$23$中的$3$，我们可以排出$23,18$，但很明显不对。而如果我们先排$18$中的$8$和$23$中的$3$，我们可以排出$23,18$；然后再排$18$中的$1$和$23$中的$2$，我们可以排出正确的顺序$18,23$。
  * 那么问题回到我们排完序后，我们怎么知道每个后缀具体的大小？我们不能简单地说按照后缀排好的数组下标来当后缀的大小，因为有些后缀相同，他们的大小应该相同，但我们又不能用$cmp()$来简单的判断 他们是否相等。我们在目光转回基数排序的双关键字$(x,y)$我们现在判断两个串是否相等，就可以等价于$(x,y)$和$(x',y')$是否相等，这是很好判断的。
  * 总结下，我们先预处理出所有后缀的长度为$1$的前缀的大小，在套用倍增思想，再套用 基数排序 利用双关键字$([i..i+2^k],[i+2^k+1..i+2^k+2^k])$ 每次把$2^k $扩展到$2^{2k}=2^k+2^k$，再把顺序映射回大小。整个算法就结束了。
  * 完结撒花