#### 虚树

* 对于一棵树，求出关于其中一个点集在这棵树上与其中的点直接相关的点
* 换句话说，就是求出 该点集关于整棵树 的$LCA$集合（包括自身）
* ![虚树](/Users/duanlingbo/Desktop/OI/knowledge/图论/树/虚树/虚树.png)
* 作用：
  * 能够作为一种树上问题的优化，但限制条件是树上问题不能与**非$LCA$的点**有直接关系。例如：树上路径
* 实现：
  * 先对于整棵有根树$dfs$，求出$dfn$序
  * 对于目标点集中的点按$dfn$序大小排序
  * 考虑到如果按照$dfn$序大小排序后，后面要做的点只会与前面连续的一段点产生新的$LCA$。
    * 证明：如果点$u​$与前面的$a​$会产生贡献，但与前面的$b​$不会产生贡献 $(dfn_a<dfn_b)​$。考虑从$a​$中可能会产生的新的$LCA​$为$a​$到根$rt​$的链上的点，而从$b​$中可能会产生的新的$LCA​$为$b​$到根$rt​$的链上的点。如果$u​$与$a​$产生的新的$LCA​$不在$b​$到$rt​$的链上，则一定在$a​$到$LCA(a,b)​$的链上，而能够产生该链上的点（$LCA ​$）的点$x​$，在$dfs​$中一定会比$b​$先访问到，即 $dfn_a<dfn_x<dfn_b​$。而 $dfn_u>dfn_b​$ 故 $u\neq x​$
  * 有了这个性质，我们就可以考虑按照$dfn$序顺序插入，根据这个性质，我们可以进一步发现这一段连续的点一定构成一条链
    * 证明：如果不是一条链，即在点$u$上有$m$个分支$a_1,a_2,...,a_m\ (dfn_{a_1}\leq...\leq dfn_{a_m})$，那么再往其中插入一点$v$，$a_1,a_2,...,a_{m-1}$的贡献都是$u$，与$a_m$产生的贡献一致，因此可以将$a_1,a_2,...,a_{m-1}$删去
  * 那么问题就被我们转化为把 点集 中的点 按$dfn$序 顺序插入 ，并维护一个 从根连出的链 。并且我们不难发现每次删去的点都是 链底部（从根往下看） 的一段点，那么这条链我们可用**栈**维护
  * 那么我们每次把准备插入的点$v$，和前一个插入的点$u$求$LCA(u,v)=fa_{u,v}$ 。我们把栈一直退到$dep_x<dep_{fa_{u,v}}$ ，并且把退出的点$a_1,a_2,...,a_m$按退栈顺序连边$(a_1,a_2),(a_2,a_3),...,(a_{m-1},a_m)$
  * 然后我们连的所有边就构成了目标点集的虚树
* 



