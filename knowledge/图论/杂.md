* <font size=6>Notice：</font>

  * <font color="red">红色</font> 为 未填的坑，
  * <font color="gree">绿色</font> 为 重点

* 对于一张图有以下几种优化方案：

  * 对边数优化：
    * 前缀和优化连边
    * 线段树优化连边
    * <font color="gree">将明显无用或可被替代的边删除</font>
  * 对点数优化：
    * 将图中必定没有贡献的点删除
    * 将图中一定连在一起的点缩为一个点
  * 对过程优化：
    * 前向星 链表 连边优化
    * <font color="red">利用线段树寻找最优化边</font>
    * 利用 **链表** 优化 查询点是否访问 的过程
      * 例如：给定一张$N\leq 10^5,M\leq 2*10^6$的图，求它的**反图**（若$N$个点的完全图为全集，则**反图**定义为 **原图的边集在全集上的补**）
        * 对$N$个点建立链表$pre[i]=i-1,nxt[i]=i+1$
        * 在每一次$bfs$扩展$u$时，将已经扩展的点在链表上删除，降低每次$O(N)$的每一个点枚举是否与$u$有连边，在之后扩展中便不会在枚举该点。
        * 具体参见 $/Desktop/OI/bzoj/bzoj1098.cpp​$

* 对于一张图的骚操作：

  * 与前缀和/线段树优化建边配套的$set$代替$use[]​$ 
  * <font color="gree">在有向图中 快速得到满足下列条件的点：</font>
    * 它能到达的点 和 能到达他它的点 的并时所有点
    * $idea$
      * 首先对这张图缩点，是该图成为$DAG$
      * 对其拓扑排序，如下图$(DAG)$
      * ![topu_连通性_1](/Users/duanlingbo/Desktop/OI/knowledge/图论/topu_连通性_1.png)
      * 拓扑排序后我们将节点按得到的拓扑序按顺序排开，如下图
      * ![topu_连通性_2](/Users/duanlingbo/Desktop/OI/knowledge/图论/topu_连通性_2.png)
      * 对于每个点$u$我们先找一个拓扑序在他后面的且与$u$相连的拓扑许最靠前的点，记为$mn_u$
      * 如果拓扑序在$u$前面的点都能到$u$，那么对于所有拓扑序在$u$前面的点$v$，要满足$mn_v$的拓扑序不在$u$后
        * 证明：若拓扑序在$u$前面的点$v$，$mn_v$的拓扑序$x$在$u$后，那么$x$不可能连向拓扑序在它前面的点，那么$v$与$u$不连通
      * 这样就能够判断拓扑序在$u$前面的点能否到$u$，然后把$DAG$反过来，在同理做一遍，就能判断拓扑序在$u$之后的点能否被$u​$访问到
  * 对于在图上判断对于特定操作有/无解的时候，将图分类，往往有些图在分类后 问题的规模 和 解的复杂度 都会有所下降
  * <font color="gree">拆点，拆边</font>
    * 对于某些点上的限制，我们可以将点拆开，类似网络流中对点访问次数限制（点权）。在加出来的边上加上该点的限制条件的等效替代版
    * 对于某些边上的限制，我们可以将边中点上加上一个点，在这个点上附上边限制的等效替代权值
    * 例：
      * $n$个点$m$条边的有向带权图，每个点的代价是**入边和出边的较大值**，求在此条件下$1\to n$的最短路
      * 分析：将连进$u$的边权排序，将连出$u$的边权排序，分别拉成一条链$p_1,p_2,...,p_c$。$p_i$向$p_{i+1}$连$w=w_{e_{i+1}}-w_{e_i}$的边；$p_{i+1}$向$p_i$连$w=0$的边。每个点连一条为 边权 的边到 边 拆出的点 上。如图
      * ![拆边_1](/Users/duanlingbo/Desktop/OI/knowledge/图论/拆边_1.png)
      * 我们可以把它转化为下图
      * ![拆边_2](/Users/duanlingbo/Desktop/OI/knowledge/图论/拆边_2.jpg)
      * 但我们注意到上图 点$1$是无法画出的 ，如果有下图的情况就$gg$了
      * ![拆边_3](/Users/duanlingbo/Desktop/OI/knowledge/图论/拆边_3.jpg)
      * 因此我们进一步思考我们发现我们并不要把具体的点建出来，我们可以把对每条边$(u,v)$建两个点，分别在$u,v$建出来的边的链上，如下图
      * ![拆边_4](/Users/duanlingbo/Desktop/OI/knowledge/图论/拆边_4.jpg)
      * 然后这个题就完美解决了，共建$2M$个点$4M$条边
  * 在求$S\to T$的最短路全部方案时不能只把$S$出发的最短路$DAG$拿出来，必须把$T$出发（反向图）的最短路$DAG$同时拿出 求**并** 得到的$DAG$才是$S\to T$的最短路全部方案的$DAG$
  * 最优化 图上一条路径的各种平均值 的要用$01$分数规划，即先 **二分答案**$ans$ 再把所有边权减去$ans$ 判定是否有 边权和为正的路径
  * 在最短路$DAG​$上找**关键边**，就可以得到最短路是否有变化
  * 斯坦纳树
    * 对于指定的$k$个点 在$n$个点$m$条边的图 上的最小生成树
    * 具体参见 $knowledge$/图论/一般图/斯坦纳树/斯坦纳树.md
  * 

* 对于一棵树的骚操作：

  * 树$\to $序列

  * 子树$\to$1个区间

  * 树链$\to\ log$个区间

  * $LCA$

    * $O(nlogn)-O(1)\ ST$
      * 见 knowledge/图论/树/dfs序/dfs序.md

  * 树上三点的交：

    * ![树上三点的交_1](/Users/duanlingbo/Desktop/OI/knowledge/图论/树上三点的交_1.png)

    * 如上图，$6\ 7\ 4$ 的交为$3​$

    * $$
      LCA(x,y,z)=LCA(x,y)\ xor\ LCA(y,z)\ xor\ LCA(x,z)
      $$

    * 应用：

      * 求树上路径的交：给出树上两条路径$AB$和$CD$求他们的交
      * ![树上路径交_lca版](/Users/duanlingbo/Desktop/OI/knowledge/图论/树上路径交_lca版.png)
      * 先求$C$和路径$AB$的交$X$，$X=LCA(A,B,C)$；再求$D$和路径$AB$的交$Y$，$Y=LCA(A,B,D)​$
        * 若$X=Y $ 则两路径交为$X$
        * 若$X\neq Y$ 则两路径交为$(X,Y)$的路径

  * 题中出现**换根操作**：

    * **$dfs$序**
      * 可无视题中 换根操作 ，但代价是在$dfs$序做 换根操作 的时候要用$Splay$ 维护序列的 翻转操作
    * **分类讨论**
      * 不管换根操作，仍然以$1$为根，在询问时分类讨论（令当前根为$rt$，询问时的根是$x$）以下以询问 子树权值和 为例：
        * 若$rt=x$ 那么直接求整棵树的权值和
        * 若$rt$不在$x$的子树中，还是直接求$x$的子树权值和即可
        * 若$rt$在$x$的子树中，求除了$rt$的子树外的整棵树的权值和

  * 基环外向树

    * 在基环外向树上做点对查询
      * 先将环上的任意一条边删去，然后分类讨论**经过该边**和**不经过该边**两种情况。

  * 虚树

    * 仅作为一种优化方法或思考方式，没有扩展意义
    * 方法参见 knowledge/图论/树/虚树/虚树.md

  * [bzoj2654 tree][https://www.lydsy.com/JudgeOnline/problem.php?id=2654]

    * <font color="red">坑</font>

  * 最小生成树过程每次添加的边均为**瓶颈边**，如果要统计一些关于每个状态边权具有$[1,R]$的性质的状态，可以在最小生成树过程将普通并查集改为**带权并查集**，并在并查集上维护这些状态

  * 在树上求 **第$k$大** 的问题，可用 $dfs$序 转化为序列上的 **第$k$大** 的问题，在用 主席树 维护

